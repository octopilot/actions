name: 'Lint'
description: >
  Runs pre-commit linting against the workspace. Language toolchains (Go, Rust,
  Node, Python, Java) are set up conditionally based on the languages detected
  in the pipeline-context produced by detect-contexts.

# ── Language-specific gotchas & resolutions ──────────────────────────────────
#
# Go — golangci-lint timeout / .golangci.yml not respected by pre-commit hook
#   The pre-commit golangci-lint hook runs inside its own sandboxed virtual
#   environment. It does NOT reliably read .golangci.yml, which means the
#   `run.timeout` directive is silently ignored on large vendor trees, causing
#   "context deadline exceeded" (exit code 4).
#   Resolution: this action uses golangci/golangci-lint-action@v6 instead of
#   the pre-commit hook for Go repos. That action reads .golangci.yml correctly
#   (including run.timeout). The pre-commit hook is skipped via SKIP=golangci-lint
#   to avoid double-running.
#   Still add .golangci.yml with a longer timeout for local `pre-commit run`:
#
#     run:
#       timeout: 10m
#
# Go — golangci-lint binary compiled with older Go than go.mod requires
#   golangci-lint pre-built releases are compiled with a specific Go version.
#   If that version is older than the project's go.mod `go` directive,
#   golangci-lint exits with "the Go language version (goX.Y) used to build
#   golangci-lint is lower than the targeted Go version (X.Y.Z)".
#   In CI: resolved via install-mode: goinstall (see step below) — compiles
#   from source using the go1.X.Y toolchain set up by actions/setup-go.
#   Locally: install using GOTOOLCHAIN so the binary is compiled with the
#   correct Go version:
#
#     GOTOOLCHAIN="go$(grep '^go ' go.mod | awk '{print $2}')" \
#       go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
#
# ── Future gotchas ───────────────────────────────────────────────────────────
# Add new entries here as they are discovered while dogfooding this action
# across different language stacks and CI environments.

inputs:
  pipeline-context:
    description: >
      Consolidated CI context object (JSON) produced by detect-contexts.
      Used to determine which language toolchains to set up before running
      pre-commit so that language-specific hooks (rustfmt, golangci-lint, etc.)
      can execute successfully.
    required: true
  golangci-lint-timeout:
    description: >
      Timeout passed to golangci-lint via --timeout. Increase for projects
      with large vendor trees. golangci-lint-action@v6 overrides the
      run.timeout value in .golangci.yml, so this must be set explicitly.
    required: false
    default: '10m'

runs:
  using: "composite"
  steps:
    # ── Parse JSON into individual step outputs ───────────────────────────────
    # fromJson() is not permitted in composite action step `if:` conditions, so
    # we extract all fields here and reference `steps.ctx.outputs.*` below.
    - name: Parse context
      id: ctx
      shell: bash
      env:
        PIPELINE_CONTEXT: ${{ inputs['pipeline-context'] }}
      run: |
        has()  { echo "$PIPELINE_CONTEXT" | jq -r --arg l "$1" 'if (.languages | index($l)) then "true" else "false" end'; }
        ver()  { echo "$PIPELINE_CONTEXT" | jq -r --arg l "$1" '.versions[$l] // ""'; }

        echo "has_go=$(has go)"           >> "$GITHUB_OUTPUT"
        echo "has_rust=$(has rust)"       >> "$GITHUB_OUTPUT"
        echo "has_node=$(has node)"       >> "$GITHUB_OUTPUT"
        echo "has_python=$(has python)"   >> "$GITHUB_OUTPUT"
        echo "has_java=$(has java)"       >> "$GITHUB_OUTPUT"
        echo "go_version=$(ver go)"       >> "$GITHUB_OUTPUT"
        echo "rust_version=$(ver rust)"   >> "$GITHUB_OUTPUT"
        echo "node_version=$(ver node)"   >> "$GITHUB_OUTPUT"
        echo "python_version=$(ver python)" >> "$GITHUB_OUTPUT"
        echo "java_version=$(ver java)"   >> "$GITHUB_OUTPUT"

    # ── Language toolchain setup (conditional on detected languages) ──────────

    - name: Setup Go
      if: steps.ctx.outputs.has_go == 'true'
      uses: actions/setup-go@v5
      with:
        go-version: ${{ steps.ctx.outputs.go_version || '1.24' }}

    - name: Setup Rust
      if: steps.ctx.outputs.has_rust == 'true'
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ steps.ctx.outputs.rust_version || 'stable' }}
        components: rustfmt, clippy

    # Cache Cargo registry and build artefacts.
    # This is required for both fmt/clippy checks below and any pre-commit Rust hooks.
    - name: Cache Cargo dependencies
      if: steps.ctx.outputs.has_rust == 'true'
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          target/
        key: ${{ runner.os }}-cargo-lint-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-lint-
          ${{ runner.os }}-cargo-

    - name: Setup Node
      if: steps.ctx.outputs.has_node == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ steps.ctx.outputs.node_version || '20' }}

    - name: Setup Python
      if: steps.ctx.outputs.has_python == 'true'
      uses: actions/setup-python@v5
      with:
        python-version: ${{ steps.ctx.outputs.python_version || '3.12' }}

    - name: Setup Java
      if: steps.ctx.outputs.has_java == 'true'
      uses: actions/setup-java@v4
      with:
        distribution: temurin
        java-version: ${{ steps.ctx.outputs.java_version || '17' }}

    # ── Rust: explicit fmt + clippy (not via pre-commit) ─────────────────────
    # pre-commit Rust hooks run inside an isolated virtualenv that lacks the
    # project's Rust toolchain and therefore cannot reliably run rustfmt or
    # clippy.  We run them explicitly here — identical to what `cargo fmt` and
    # `cargo clippy` do locally — so lint is never silently skipped on repos
    # that do not have rustfmt/clippy hooks in .pre-commit-config.yaml.
    - name: Check Rust formatting
      if: steps.ctx.outputs.has_rust == 'true'
      shell: bash
      run: cargo fmt --all -- --check

    - name: Run Clippy
      if: steps.ctx.outputs.has_rust == 'true'
      shell: bash
      run: |
        cargo clippy --all-targets --all-features -- -D warnings \
          || echo "⚠️  Clippy found warnings (non-blocking — fix before merge)"

    # ── Go: run golangci-lint via its dedicated action ────────────────────────
    # The pre-commit golangci-lint hook runs inside its own sandboxed virtual
    # environment and does not reliably read .golangci.yml (the timeout
    # directive is silently ignored, causing "context deadline exceeded" on
    # large vendor trees). golangci/golangci-lint-action:
    #   • reads .golangci.yml correctly (including run.timeout)
    #   • caches build artefacts across runs for faster subsequent executions
    #   • manages the golangci-lint binary version automatically
    # We skip the golangci-lint hook in the pre-commit step below to avoid
    # running it twice.
    - name: Run golangci-lint
      if: steps.ctx.outputs.has_go == 'true'
      uses: golangci/golangci-lint-action@v6
      with:
        version: latest
        # install-mode: goinstall compiles golangci-lint from source using the
        # Go toolchain already configured by actions/setup-go above (go1.25.6
        # in this case). The default binary download mode grabs a pre-built
        # release that may have been compiled with an older Go, causing:
        #   "the Go language version (goX.Y) used to build golangci-lint is
        #    lower than the targeted Go version (X.Y.Z)"
        install-mode: goinstall
        # golangci-lint-action@v6 passes --timeout internally and overrides
        # the run.timeout value in .golangci.yml. Set it from the input so
        # callers can tune it for their vendor tree size.
        args: --timeout=${{ inputs['golangci-lint-timeout'] }}


    # ── Helm: install and lint any chart directories ──────────────────────────
    # Standard YAML checks (e.g. check-yaml) fail on Helm templates ({{ .Values }}).
    # Repos should exclude chart/templates from check-yaml and run helm lint instead.
    # We install Helm here so pre-commit hooks or explicit steps can run helm lint.
    - name: Setup Helm
      shell: bash
      run: |
        if command -v helm &>/dev/null; then
          echo "Helm already installed: $(helm version --short)"
          exit 0
        fi
        HELM_VERSION="${HELM_VERSION:-3.16.4}"
        echo "Installing Helm ${HELM_VERSION}..."
        curl -sSL "https://get.helm.sh/helm-v${HELM_VERSION}-linux-amd64.tar.gz" | tar -xzf - -C /tmp
        sudo mv /tmp/linux-amd64/helm /usr/local/bin/helm
        helm version --short

    - name: Lint Helm charts
      shell: bash
      run: |
        set -e
        charts="$(find . -name 'Chart.yaml' -not -path './.git/*' -not -path './.*' 2>/dev/null)" || true
        if [ -z "$charts" ]; then
          echo "No Chart.yaml found, skipping helm lint"
          exit 0
        fi
        echo "$charts" | while read -r chart_file; do
          dir="$(dirname "$chart_file")"
          echo "Building dependencies and linting chart: $dir"
          (cd "$dir" && helm dependency build . 2>/dev/null || true)
          helm lint "$dir"
        done

    # ── pre-commit ────────────────────────────────────────────────────────────

    - name: Install pre-commit
      shell: bash
      run: pip install pre-commit

    - name: Cache pre-commit environments
      uses: actions/cache@v4
      with:
        path: ~/.cache/pre-commit
        key: pre-commit-${{ runner.os }}-${{ hashFiles('.pre-commit-config.yaml') }}
        restore-keys: |
          pre-commit-${{ runner.os }}-

    - name: Run pre-commit
      shell: bash
      env:
        # Skip the golangci-lint hook when Go is present — it is run above via
        # golangci/golangci-lint-action which correctly reads .golangci.yml.
        SKIP: ${{ steps.ctx.outputs.has_go == 'true' && 'golangci-lint' || '' }}
      run: |
        if [ ! -f .pre-commit-config.yaml ]; then
          echo "ℹ️  No .pre-commit-config.yaml found — skipping pre-commit run"
          echo "   (fmt/clippy were already run explicitly above for Rust repos)"
          exit 0
        fi
        pre-commit run --all-files
