name: 'Lint'
description: >
  Runs pre-commit linting against the workspace. Language toolchains (Go, Rust,
  Node, Python, Java) are set up conditionally based on the languages detected
  in the pipeline-context produced by detect-contexts.

# ── Language-specific gotchas & resolutions ──────────────────────────────────
#
# Go — golangci-lint timeout / .golangci.yml not respected by pre-commit hook
#   The pre-commit golangci-lint hook runs inside its own sandboxed virtual
#   environment. It does NOT reliably read .golangci.yml, which means the
#   `run.timeout` directive is silently ignored on large vendor trees, causing
#   "context deadline exceeded" (exit code 4).
#   Resolution: this action uses golangci/golangci-lint-action@v6 instead of
#   the pre-commit hook for Go repos. That action reads .golangci.yml correctly
#   (including run.timeout). The pre-commit hook is skipped via SKIP=golangci-lint
#   to avoid double-running.
#   Still add .golangci.yml with a longer timeout for local `pre-commit run`:
#
#     run:
#       timeout: 10m
#
# Go — golangci-lint binary compiled with older Go than go.mod requires
#   In CI: resolved automatically — golangci-lint-action downloads a compatible
#   binary. No action needed.
#   Locally: install using GOTOOLCHAIN so the binary is compiled with the
#   correct Go version:
#
#     GOTOOLCHAIN="go$(grep '^go ' go.mod | awk '{print $2}')" \
#       go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
#
# ── Future gotchas ───────────────────────────────────────────────────────────
# Add new entries here as they are discovered while dogfooding this action
# across different language stacks and CI environments.

inputs:
  pipeline-context:
    description: >
      Consolidated CI context object (JSON) produced by detect-contexts.
      Used to determine which language toolchains to set up before running
      pre-commit so that language-specific hooks (rustfmt, golangci-lint, etc.)
      can execute successfully.
    required: true

runs:
  using: "composite"
  steps:
    # ── Parse JSON into individual step outputs ───────────────────────────────
    # fromJson() is not permitted in composite action step `if:` conditions, so
    # we extract all fields here and reference `steps.ctx.outputs.*` below.
    - name: Parse context
      id: ctx
      shell: bash
      env:
        PIPELINE_CONTEXT: ${{ inputs['pipeline-context'] }}
      run: |
        has()  { echo "$PIPELINE_CONTEXT" | jq -r --arg l "$1" 'if (.languages | index($l)) then "true" else "false" end'; }
        ver()  { echo "$PIPELINE_CONTEXT" | jq -r --arg l "$1" '.versions[$l] // ""'; }

        echo "has_go=$(has go)"           >> "$GITHUB_OUTPUT"
        echo "has_rust=$(has rust)"       >> "$GITHUB_OUTPUT"
        echo "has_node=$(has node)"       >> "$GITHUB_OUTPUT"
        echo "has_python=$(has python)"   >> "$GITHUB_OUTPUT"
        echo "has_java=$(has java)"       >> "$GITHUB_OUTPUT"
        echo "go_version=$(ver go)"       >> "$GITHUB_OUTPUT"
        echo "rust_version=$(ver rust)"   >> "$GITHUB_OUTPUT"
        echo "node_version=$(ver node)"   >> "$GITHUB_OUTPUT"
        echo "python_version=$(ver python)" >> "$GITHUB_OUTPUT"
        echo "java_version=$(ver java)"   >> "$GITHUB_OUTPUT"

    # ── Language toolchain setup (conditional on detected languages) ──────────

    - name: Setup Go
      if: steps.ctx.outputs.has_go == 'true'
      uses: actions/setup-go@v5
      with:
        go-version: ${{ steps.ctx.outputs.go_version || '1.24' }}

    - name: Setup Rust
      if: steps.ctx.outputs.has_rust == 'true'
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ steps.ctx.outputs.rust_version || 'stable' }}
        components: rustfmt, clippy

    - name: Setup Node
      if: steps.ctx.outputs.has_node == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ steps.ctx.outputs.node_version || '20' }}

    - name: Setup Python
      if: steps.ctx.outputs.has_python == 'true'
      uses: actions/setup-python@v5
      with:
        python-version: ${{ steps.ctx.outputs.python_version || '3.12' }}

    - name: Setup Java
      if: steps.ctx.outputs.has_java == 'true'
      uses: actions/setup-java@v4
      with:
        distribution: temurin
        java-version: ${{ steps.ctx.outputs.java_version || '17' }}

    # ── Go: run golangci-lint via its dedicated action ────────────────────────
    # The pre-commit golangci-lint hook runs inside its own sandboxed virtual
    # environment and does not reliably read .golangci.yml (the timeout
    # directive is silently ignored, causing "context deadline exceeded" on
    # large vendor trees). golangci/golangci-lint-action:
    #   • reads .golangci.yml correctly (including run.timeout)
    #   • caches build artefacts across runs for faster subsequent executions
    #   • manages the golangci-lint binary version automatically
    # We skip the golangci-lint hook in the pre-commit step below to avoid
    # running it twice.
    - name: Run golangci-lint
      if: steps.ctx.outputs.has_go == 'true'
      uses: golangci/golangci-lint-action@v6
      with:
        version: latest

    # ── pre-commit ────────────────────────────────────────────────────────────

    - name: Install pre-commit
      shell: bash
      run: pip install pre-commit

    - name: Cache pre-commit environments
      uses: actions/cache@v4
      with:
        path: ~/.cache/pre-commit
        key: pre-commit-${{ runner.os }}-${{ hashFiles('.pre-commit-config.yaml') }}
        restore-keys: |
          pre-commit-${{ runner.os }}-

    - name: Run pre-commit
      shell: bash
      env:
        # Skip the golangci-lint hook when Go is present — it is run above via
        # golangci/golangci-lint-action which correctly reads .golangci.yml.
        SKIP: ${{ steps.ctx.outputs.has_go == 'true' && 'golangci-lint' || '' }}
      run: pre-commit run --all-files
