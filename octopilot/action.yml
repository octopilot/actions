name: 'Octopilot Build'
description: 'Build and push container images using Octopilot Pipeline Tools.'
inputs:
  version:
    description: 'Version to build/tag (defaults to ref_name).'
    required: false
    default: ''
  registry:
    description: 'Target registry (e.g. ghcr.io/octopilot). Ignored when ttl-uuid is set (push goes to ttl.sh).'
    required: false
    default: ''
  ttl-uuid:
    description: 'When set, push to ttl.sh/<ttl-uuid>-<suffix>:<ttl-tag> and write build_result.json (ephemeral integration). Overrides registry.'
    required: false
    default: ''
  ttl-tag:
    description: 'Tag for ttl.sh when ttl-uuid is set (default 1h).'
    required: false
    default: '1h'
  platforms:
    description: 'Comma-separated list of platforms to build for (e.g. linux/amd64).'
    required: false
    default: 'linux/amd64'
  artifact:
    description: 'Build only this artifact (exact image name from skaffold, e.g. ghcr.io/org/myimage). For matrix/fan-out integration builds.'
    required: false
    default: ''
  op_version:
    description: 'Version of octopilot-pipeline-tools to use (e.g. v1.0.10).'
    required: false
    default: 'v1.0.10'
  sbom_output:
    description: 'Path to output SBOMs.'
    required: false
    default: 'dist/sbom'
  op_binary:
    description: 'Path to op binary (used only when build_bypass is true).'
    required: false
    default: 'op'
  build_bypass:
    description: 'Bypass container execution and run op directly (for bootstrapping).'
    required: false
    default: 'false'
outputs:
  digest:
    description: 'Container image digest (e.g. sha256:...).'
    value: ${{ steps.build.outputs.digest }}
  tag:
    description: 'Full image ref from build_result.json (e.g. ttl.sh/<uuid>-<suffix>:<tag>@sha256:... or registry/image:tag@sha256:...).'
    value: ${{ steps.build.outputs.tag }}
runs:
  using: "composite"
  steps:
    - name: Build and Push
      id: build
      shell: bash
      env:
        INPUT_VERSION: ${{ inputs.version }}
        INPUT_REGISTRY: ${{ inputs.registry }}
        INPUT_TTL_UUID: ${{ inputs.ttl-uuid }}
        INPUT_TTL_TAG: ${{ inputs.ttl-tag }}
        INPUT_PLATFORMS: ${{ inputs.platforms }}
        INPUT_ARTIFACT: ${{ inputs.artifact }}
        INPUT_OP_VERSION: ${{ inputs.op_version }}
        INPUT_SBOM_OUTPUT: ${{ inputs.sbom_output }}
        INPUT_OP_BINARY: ${{ inputs.op_binary }}
        INPUT_BUILD_BYPASS: ${{ inputs.build_bypass }}
      run: |
        # Determine version
        VERSION="${INPUT_VERSION}"
        if [ -z "$VERSION" ]; then
          VERSION="${GITHUB_REF_NAME}"
        fi

        # Create SBOM output directory
        mkdir -p "${INPUT_SBOM_OUTPUT}"

        # Require either ttl-uuid (ephemeral ttl.sh) or registry
        if [ -n "${INPUT_TTL_UUID}" ]; then
          echo "Using ttl.sh ephemeral build (op --ttl-uuid / --ttl-tag)."
        elif [ -n "${INPUT_REGISTRY}" ]; then
          echo "Using registry: ${INPUT_REGISTRY}"
        else
          echo "::error::Set either registry or ttl-uuid."
          exit 1
        fi

        if [ "${INPUT_BUILD_BYPASS}" == "true" ]; then
            echo "Bypassing container execution. Running op directly..."
            export DOCKER_METADATA_OUTPUT_VERSION="${VERSION}"
            export GITHUB_ACTIONS="true"
            export CI="true"
            
            # Ensure safe directory
            git config --global --add safe.directory "$GITHUB_WORKSPACE"
            
            # Ensure op is executable
            chmod +x "${INPUT_OP_BINARY}"
            
            OP_ARTIFACT=""
            [ -n "${INPUT_ARTIFACT}" ] && OP_ARTIFACT="--artifact ${INPUT_ARTIFACT}"
            if [ -n "${INPUT_TTL_UUID}" ]; then
              "${INPUT_OP_BINARY}" build --ttl-uuid "${INPUT_TTL_UUID}" --ttl-tag "${INPUT_TTL_TAG:-1h}" $OP_ARTIFACT --platform "${INPUT_PLATFORMS}" --push --sbom-output "${INPUT_SBOM_OUTPUT}"
            else
              "${INPUT_OP_BINARY}" build --repo "${INPUT_REGISTRY}" $OP_ARTIFACT --platform "${INPUT_PLATFORMS}" --push --sbom-output "${INPUT_SBOM_OUTPUT}"
            fi
        else
            # Determine builder image tag
            IMAGE_TAG="${INPUT_OP_VERSION}"
            if [ "${IMAGE_TAG}" == "latest" ]; then
                IMAGE_TAG="latest"
            fi
            
            IMAGE="ghcr.io/octopilot/op:${IMAGE_TAG}"
            echo "Using builder image: $IMAGE"

            # Pass ttl-uuid/ttl-tag and registry via env so op args are built inside the
            # container (avoids interpolating user input in the host shell). op supports
            # --ttl-uuid / --ttl-tag and writes build_result.json with ttl.sh refs.
            # Mounts: docker socket, workspace, ~/.docker (for registry auth when not using ttl.sh).
            docker run --rm \
                -v /var/run/docker.sock:/var/run/docker.sock \
                -v "$GITHUB_WORKSPACE:/workspace" \
                -v "${HOME}/.docker:/root/.docker:ro" \
                -w "/workspace" \
                -e DOCKER_METADATA_OUTPUT_VERSION="${VERSION}" \
                -e GITHUB_ACTIONS="true" \
                -e CI="true" \
                -e GITHUB_WORKSPACE="${GITHUB_WORKSPACE}" \
                -e OP_TTL_UUID="${INPUT_TTL_UUID}" \
                -e OP_TTL_TAG="${INPUT_TTL_TAG}" \
                -e OP_REGISTRY="${INPUT_REGISTRY}" \
                -e OP_ARTIFACT="${INPUT_ARTIFACT}" \
                -e OP_PLATFORMS="${INPUT_PLATFORMS}" \
                -e OP_SBOM_OUTPUT="${INPUT_SBOM_OUTPUT}" \
                --entrypoint /bin/sh \
                "$IMAGE" \
                -c 'git config --global --add safe.directory /workspace && \
                  if [ -n "$OP_TTL_UUID" ]; then
                    OP_REPO_ARG=""; OP_EXTRA="--ttl-uuid $OP_TTL_UUID --ttl-tag ${OP_TTL_TAG:-1h}"
                  else
                    OP_REPO_ARG="--repo $OP_REGISTRY"; OP_EXTRA=""
                  fi && \
                  OP_ARTIFACT_ARG=""; [ -n "$OP_ARTIFACT" ] && OP_ARTIFACT_ARG="--artifact $OP_ARTIFACT" && \
                  op build $OP_REPO_ARG $OP_EXTRA $OP_ARTIFACT_ARG --platform "$OP_PLATFORMS" --push --sbom-output "$OP_SBOM_OUTPUT"'
        fi

        # Package SBOMs if directory exists and is not empty
        if [ -d "${INPUT_SBOM_OUTPUT}" ] && [ "$(ls -A ${INPUT_SBOM_OUTPUT})" ]; then
            tar -czvf "${INPUT_SBOM_OUTPUT}.tar.gz" -C "${INPUT_SBOM_OUTPUT}" .
        fi

        # Extract digest and full tag from build_result.json (last entry = application image).
        # With ttl-uuid, tag is e.g. ttl.sh/<uuid>-<suffix>:<ttl-tag>@sha256:...
        if [ -f "build_result.json" ]; then
            TAG=$(jq -r '.builds[-1].tag' build_result.json)
            DIGEST=$(echo "$TAG" | awk -F'@' '{print $2}')
            echo "digest=$DIGEST" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
        fi
